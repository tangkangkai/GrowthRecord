## 修炼： 程序之术

### 架构与实现

![](https://static001.geekbang.org/resource/image/9c/5b/9cf03e6bdb195f8eca40386e297e0d5b.png)

* 定义： **架构**是关注系统结构与行为的决策流，而**实现**是围绕架构的程序开发过程

* 架构关注点：熵
    * 软件系统或架构，会因为变化而腐坏
    * 超过临界值，软件生命周期到头
    * 重构与优化是减熵，让其在安全范围内波动
* 实现关注点：简
    * 简单、简洁、简明、简化
    * 减少代码量、开发时间、测试时间、维护理解沟通成本

* 架构与实现偏离
    * 大架构难以跟进所有实现细节
    * 抓战略方向上的，放战术细节上的

### 模式与框架

**设计模式**

* 模式
    * 前人解决某类问题方式的总结，解决问题域的优化路径
    > 每个模式都描述了一个在我们的环境中不断出现的问题，然后描述了该问题的解决方案的核心,通过这种方式，我们可以无数次地重用那些已有的成功的解决方案,无须再重复相同的工作。 - 《建筑的永恒之道》
* 设计模式是一种知识，需要大量的例子来熟练掌握
    
**开发框架（Framework）**

* 一个框架是一个可复用的设计组件，它统一定义了高层设计和接口，使得从框架构建应用程序变得非常容易
    * 快速开发
    * 代码复用

* 框架的束缚
    * 框架对通用性的追求导致框架庞大、复杂、高抽象，不容易被理解
    * 同一问题不同框架带来了解、评估、取舍的过程

**两者关系**

* 共同点
    * 提供了问题重用的方案
        * 框架: 代码复用
        * 模式： 设计复用
* 框架是程序代码，而模式是关于这些程序代码的知识
    * 框架采用了一种结构化的方式来对特定的编程领域进行了规范化，在框架中直接就会包含很多模式的应用、模式的设计概念、领域的优化实践等

### 多维与视图

* 组成视图
    * 表达了系统由哪些子系统、服务、组件部分构成
    * 对服务进行大类划分，用不同的颜色表达
    * 每一个服务下的微服务按照两大原则细分
        * 单一化：每个服务提供单一内聚的功能集
        * 正交化：任何一个功能仅由一个服务提供，无提供多个类似功能的服务。
    <img src="https://static001.geekbang.org/resource/image/a0/d9/a075c277981b3e56c347dc05591f18d9.png" width="600" height="400" />
* 交互视图
    * 交互视图，表达了系统或服务与外部系统或服务的协作关系，也即：依赖与被依赖。
    * 像地图一样通过不同倍率缩放
        * 如果我们把目光聚焦在一个服务上，以其为中心的表达方式，就体现了该服务的依赖协作关系
    <img src="https://static001.geekbang.org/resource/image/4b/f4/4bf63fcd735af78c2258c1ddd8cde0f4.png" width="600" height="400" />
* 部署视图
    * 和交互视图相似，关注系统组合、协作和依存关系
    * 表达系统的部署结构与环境
* 流程视图
    * 表达系统内部实现的功能和控制逻辑流程
    * 业务与控制
    * 重点在于表达内部逻辑而不是遵循语法
    <img src="https://static001.geekbang.org/resource/image/2b/2c/2b8ea4c772c314e3bb7b246501bea32c.png" width="600" height="400" />
* 状态视图
    * 表达系统内部管理了哪些状态以及状态的变迁转移路径
    * 状态是业务的核心，用户行为会导致状态迁移。尽可能把状态限制在系统有限的范围内，控制复杂边界
    <img src="https://static001.geekbang.org/resource/image/6b/c3/6bbb1c9be59fcd472efd77d89cb057c3.png" width="400" height="400" />

### 代码与分类

* 功能
    * 实现需求的业务逻辑代码，反映真实业务场景，包含大量领域知识
    * 最难的不是编码本身，而是搞清楚功能 _背后的需求_ 并得到 _正确的理解_ 
* 控制
    * 控制业务功能逻辑代码执行的代码，即业务逻辑的执行策略
        * 编程领域熟悉的各类设计模式，都是在讲关于控制代码的逻辑
    * 与业务功能逻辑不直接相关，与性能、稳定性、可用性直接相关
* 运维
    * 方便程序检测、诊断和运行时处理的代码
        * 诊断: 日志 - 输出多少、哪里输出、输出级别
        * 检测：系统异常的主动状态汇报 
    * 对系统行为进行改变
        * 备份、恢复数据
        * 实时流量调度

### 粗放与精益（编程思路）

* 多与粗放
    * 例子：需求到开发手上后，开始编码，编码完成，人肉测试，没问题后快速发布到线上，然后进入下一个迭代。
    * 必要的成长阶段，核心在于迭代（试错+反馈）
* 好与精益
    * 质量、成本、效率
    * 不要被完美主义羁绊

### 炫技与克制（编程思路）

* 炫技
    * 有时会增加不必要的抽象和复杂度
* 克制
    * 代码直观、可读、高效、干净
    * 不是看到“坏”代码就理科动手改，而是等待合适的时机重构

### bug的属性

* bug的空间属性
    * 环境过敏
        * 了解环境
        * 信息收集
* bug的时间属性
    * 周期特点（内存等资源相关）
    * 非规律性、神出鬼没
        * 用profiler等性能剖析工具
* bug的反复出现
    * 粗心大意
        * 开发规范、代码风格、流程约束、代码评审、工具检查
        * 单元测试
    * 认知偏差（默认事物运行方式）
        * 团队总结分享
        * 静态代码扫描工具
    * 熵增问题（复杂、高耦合）
        * 重构优化
        * 微服务

## 修行： 由术入道

### 计划

* 根源
    * 自我实现的需求
* 方法
    * 目标 - HARD
        * Heartfelt 衷心的，源自内心的
        * Animated 活生生，有画面感的
        * Required 必须的，需求明确的
        * Difficult 困难的，有难度的
    * 方法 
        * 时间 - 短中长期
        * 路径 - SMART
* 检视
    * 精确理性计算，不靠模糊感觉
    * 有限的时间，适合的周期，兴趣的选择，郑重的承诺
* 评估
    * 时间/机会成本的评估